<?xml version="1.0" encoding="UTF-8"?>

<!--suppress ALL -->
<beans
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:property="http://www.springframework.org/schema/p"
    xmlns:util="http://www.springframework.org/schema/util"
    xmlns:transaction="http://www.springframework.org/schema/tx"
    xmlns:aop="http://www.springframework.org/schema/aop"

    xsi:schemaLocation="
			http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context-3.0.xsd
            http://www.springframework.org/schema/util
            http://www.springframework.org/schema/util/spring-util.xsd
            http://www.springframework.org/schema/tx
            http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
            http://www.springframework.org/schema/aop
            http://www.springframework.org/schema/aop/spring-aop-3.0.xsd">

    <description>
        This file is only used in the integration tests to load all the configuration files when normally
        all the configuration files will be loaded by the web application configuration by scanning the
        starting/user directory for spring-*.xml files.
    </description>

    <context:property-placeholder
        location="classpath*:**/experimental/spring.properties"
        properties-ref="ikube.discover.tool.PropertyConfigurer" />

    <!-- This bean will look through the classpath and load every Spring properties file it finds. -->
    <bean
        id="ikube.discover.tool.PropertyConfigurer"
        class="ikube.discover.tool.PropertyConfigurer"
        lazy-init="false"
        init-method="initialize"
        property:fileNamePattern="spring.properties"/>

    <context:spring-configured />
    <context:component-scan base-package="ikube" />
    <context:annotation-config/>
    <transaction:annotation-driven transaction-manager="transactionManager"/>

    <import resource="spring-h2-jdbc.xml"/>
    <import resource="spring-grid-gain.xml"/>

    <bean
        name="defaultPersistenceUnitManager"
        class="org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager"
        depends-on="h2DataSourceBinder"
        property:persistenceXmlLocations-ref="persistenceXmlLocations"
        property:defaultDataSource-ref="${idiscover.dataSource}"/>
     <!-- property:defaultDataSource-ref="${idiscover.dataSource}" -->
    <util:list id="persistenceXmlLocations">
        <value>classpath*:META-INF/persistence/persistence.xml</value>
    </util:list>

    <!-- This bean does the injection of the entity manager into the dao. -->
    <bean
        class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/>
    <bean
        name="transactionManager"
        class="org.springframework.orm.jpa.JpaTransactionManager"
        property:entityManagerFactory-ref="entityManagerFactory"/>
    <bean
        name="entityManagerFactory"
        class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"
        lazy-init="false"
        property:jpaVendorAdapter-ref="jpaAdapter"
        property:jpaPropertyMap-ref="jpaPropertyMap"
        property:persistenceUnitName="${idiscover.persistenceUnit}"
        property:persistenceUnitManager-ref="defaultPersistenceUnitManager"
        property:dataSource-ref="${idiscover.dataSource}"/>
    <!--
        property:loadTimeWeaver-ref="loadTimeWeaver"
        property:dataSource-ref="${idiscover.dataSource}"
    -->

    <!--<bean-->
        <!--name="loadTimeWeaver"-->
        <!--class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"/>-->
    <bean
        name="jpaAdapter"
        class="org.springframework.orm.jpa.vendor.EclipseLinkJpaVendorAdapter"
        property:database="${idiscover.dataSourceType}"
        property:showSql="true"/>
    <transaction:advice id="transactionAdvice" transaction-manager="transactionManager">
        <transaction:attributes>
            <transaction:method name="find*"/>
            <transaction:method name="merge*"/>
            <transaction:method name="persist*"/>
            <transaction:method name="remove*"/>
            <transaction:method name="execute*"/>
        </transaction:attributes>
    </transaction:advice>

    <util:map id="jpaPropertyMap">
        <!--<property name="javax.persistence.jdbc.user" value="sa"/>-->
        <!--<property name="javax.persistence.jdbc.password" value=""/>-->
        <!--<property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/>-->
        <!--<property name="javax.persistence.jdbc.url" value="jdbc:h2:file:i-discover"/>-->
        <!--<entry key="eclipselink.ddl-generation" value="create-tables"/>-->
        <!--<entry key="eclipselink.logging.level.sql" value="FINEST"/>-->
        <!--<entry key="eclipselink.logging.parameters" value="true"/>-->
        <!--<entry key="eclipselink.ddl-generation.output-mode" value="both"/>-->

        <!-- <entry key="openjpa.ConnectionFactoryProperties" value="PrettyPrint=true,PrettyPrintLineLength=150" /> -->
        <!--<entry key="openjpa.Log" value="DefaultLevel=TRACE,JDBC=TRACE,SQL=TRACE,File=openjpa.log,Runtime=TRACE,Tool=TRACE"/>-->
        <!--<entry key="openjpa.ConnectionFactoryProperties" value="PrintParameters=true" />-->

        <!--<entry key="openjpa.DataCache" value="true(CacheSize=0,SoftReferenceSize=0)"/>-->
        <!--<entry key="openjpa.QueryCache" value="true(CacheSize=0,SoftReferenceSize=0)"/>-->

        <!--<entry key="openjpa.Optimistic" value="true"/>-->
        <!--<entry key="openjpa.ReadLockLevel" value="none"/>-->
        <!--<entry key="openjpa.WriteLockLevel" value="write"/>-->
        <!--<entry key="openjpa.NontransactionalRead" value="true"/>-->
        <!--<entry key="openjpa.LockTimeout" value="60000"/>-->

        <!--<entry key="openjpa.Multithreaded" value="true"/>-->
        <!--<entry key="openjpa.AutoDetach" value="commit"/>-->
        <!--<entry key="openjpa.FlushBeforeQueries" value="true"/> &lt;!&ndash; Dangerous, should be false &ndash;&gt;-->
        <!--<entry key="openjpa.DynamicEnhancementAgent" value="false"/>-->
        <!--<entry key="openjpa.RuntimeUnenhancedClasses" value="unsupported"/>-->
        <!--<entry key="openjpa.jdbc.DBDictionary" value="${idiscover.jdbc.dictionary}"/>-->
        <!--<entry key="openjpa.MetaDataFactory" value="jpa(Types=ikube.discover.database.model.Persistable;ikube.discover.database.model.Analysis)"/>-->
        <!--<entry key="openjpa.jdbc.SynchronizeMappings" value="buildSchema(ForeignKeys=true)"/>-->

        <!--
            There is a bug somewhere, in OpenJpa or H2 but the 'FOR UPDATE LIMIT ?'
             seems to be rejected by H2, and incidentally for MySql too. Perhaps the others
             accept this syntax.
        -->
        <!-- (VersionCheckOnReadLock=false,VersionUpdateOnWriteLock=false) -->
        <!--<entry key="openjpa.LockManager" value="pessimistic"/>-->

        <!--<entry key="openjpa.Connection2UserName" value="${idiscover.jdbc.userid}"/>-->
        <!--<entry key="openjpa.Connection2Password" value="${idiscover.jdbc.password}"/>-->
        <!--<entry key="openjpa.Connection2URL" value="${idiscover.jdbc.url}"/>-->
        <!--<entry key="openjpa.Connection2DriverName" value="${idiscover.jdbc.driver}"/>-->

        <!--<entry key="openjpa.ConnectionUserName" value="${idiscover.jdbc.userid}"/>-->
        <!--<entry key="openjpa.ConnectionPassword" value="${idiscover.jdbc.password}"/>-->
        <!--<entry key="openjpa.ConnectionURL" value="${idiscover.jdbc.url}"/>-->
        <!--<entry key="openjpa.ConnectionDriverName" value="${idiscover.jdbc.driver}"/>-->

        <!-- ,Indexes=true,SchemaAction='drop,add',SchemaAction='add,deleteTableContents' -->
        <!--<entry key="openjpa.jdbc.SchemaFactory" value="native(ForeignKeys=true)"/>-->
        <!--<entry key="openjpa.InverseManager" value="true(Action=warn)"/>-->
    </util:map>

    <bean
        name="ikube.discover.database.IDataBase"
        class="ikube.discover.database.DataBaseJpaH2"
        lazy-init="true"
        depends-on="nonXaDataSourceH2"/>

    <bean
        id="search-context"
        class="ikube.discover.Context"
        depends-on="ikube.discover.database.IDataBase"
        property:name="search-context"/>

    <bean
        id="ikube.discover.schedule.Scheduler"
        class="ikube.discover.schedule.Scheduler"
        lazy-init="false"
        depends-on="ikube.discover.cluster.IClusterManager"
        property:clusterManager-ref="ikube.discover.cluster.IClusterManager"/>

    <aop:config>
        <aop:pointcut id="dataBaseJpaH2" expression="execution(* ikube.discover.database.DataBaseJpaH2.*(..))"/>
        <aop:advisor advice-ref="transactionAdvice" pointcut-ref="dataBaseJpaH2"/>
    </aop:config>

    <util:list id="contexts">
        <ref bean="search-context" />
    </util:list>

</beans>