<?xml version="1.0" encoding="UTF-8"?>

<!--suppress ALL -->
<beans
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:property="http://www.springframework.org/schema/p"
    xmlns:util="http://www.springframework.org/schema/util"
    xmlns:transaction="http://www.springframework.org/schema/tx"
    xmlns:aop="http://www.springframework.org/schema/aop"

    xsi:schemaLocation="
			http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context-3.0.xsd
            http://www.springframework.org/schema/util
            http://www.springframework.org/schema/util/spring-util.xsd
            http://www.springframework.org/schema/tx
            http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
            http://www.springframework.org/schema/aop
            http://www.springframework.org/schema/aop/spring-aop-3.0.xsd">

    <description>
        This file is only used in the integration tests to load all the configuration files when normally
        all the configuration files will be loaded by the web application configuration by scanning the
        starting/user directory for spring-*.xml files.
    </description>

    <context:property-placeholder
        location="classpath*:**/experimental/spring.properties"
        properties-ref="ikube.discover.tool.PropertyConfigurer" />

    <!-- This bean will look through the classpath and load every Spring properties file it finds. -->
    <bean
        id="ikube.discover.tool.PropertyConfigurer"
        class="ikube.discover.tool.PropertyConfigurer"
        lazy-init="false"
        init-method="initialize"
        property:fileNamePattern="spring.properties"/>

    <import resource="spring-h2-jdbc.xml"/>
    <import resource="spring-grid-gain.xml"/>

    <bean
        name="defaultPersistenceUnitManager"
        class="org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager"
        property:persistenceXmlLocations-ref="persistenceXmlLocations"
        property:defaultDataSource-ref="${idiscover.dataSource}"/>
    <util:list id="persistenceXmlLocations">
        <value>classpath*:META-INF/persistence.xml</value>
    </util:list>

    <!-- This bean does the injection of the entity manager into the dao. -->
    <bean
        class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/>
    <bean
        name="transactionManager"
        class="org.springframework.orm.jpa.JpaTransactionManager"
        property:entityManagerFactory-ref="entityManagerFactory"/>
    <bean
        name="entityManagerFactory"
        class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"
        lazy-init="false"
        property:jpaVendorAdapter-ref="jpaAdapter"
        property:jpaPropertyMap-ref="jpaPropertyMap"
        property:dataSource-ref="${idiscover.dataSource}"
        property:persistenceUnitName="${idiscover.persistenceUnit}"
        property:persistenceUnitManager-ref="defaultPersistenceUnitManager"
        property:loadTimeWeaver-ref="loadTimeWeaver"/>
    <bean
        name="loadTimeWeaver"
        class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"/>
    <bean
        name="jpaAdapter"
        class="org.springframework.orm.jpa.vendor.OpenJpaVendorAdapter"
        property:database="${idiscover.dataSourceType}"
        property:showSql="false"/>
    <util:map id="jpaPropertyMap">
        <!-- <entry key="openjpa.ConnectionFactoryProperties" value="PrettyPrint=true,PrettyPrintLineLength=150" /> -->
        <entry key="openjpa.Log"
               value="DefaultLevel=INFO,JDBC=INFO,SQL=INFO,File=openjpa.log,Runtime=INFO,Tool=INFO"/>

        <entry key="openjpa.DataCache" value="true(CacheSize=0,SoftReferenceSize=0)"/>
        <entry key="openjpa.QueryCache" value="true(CacheSize=0,SoftReferenceSize=0)"/>

        <entry key="openjpa.Optimistic" value="true"/>
        <entry key="openjpa.ReadLockLevel" value="none"/>
        <entry key="openjpa.WriteLockLevel" value="write"/>
        <entry key="openjpa.NontransactionalRead" value="true"/>
        <entry key="openjpa.LockTimeout" value="60000"/>

        <!--
            There is a bug somewhere, in OpenJpa or H2 but the 'FOR UPDATE LIMIT ?'
             seems to be rejected by H2, and incidentally for MySql too. Perhaps the others
             accept this syntax.
        -->
        <!-- (VersionCheckOnReadLock=false,VersionUpdateOnWriteLock=false) -->
        <!--<entry key="openjpa.LockManager" value="pessimistic"/>-->

        <entry key="openjpa.Multithreaded" value="true"/>
        <entry key="openjpa.AutoDetach" value="commit"/>
        <entry key="openjpa.FlushBeforeQueries" value="false"/>
        <entry key="openjpa.DynamicEnhancementAgent" value="true"/>
        <entry key="openjpa.RuntimeUnenhancedClasses" value="supported"/>
        <entry key="openjpa.jdbc.DBDictionary" value="${idiscover.jdbc.dictionary}"/>

        <entry key="openjpa.Connection2UserName" value="${idiscover.jdbc.userid}"/>
        <entry key="openjpa.Connection2Password" value="${idiscover.jdbc.password}"/>
        <entry key="openjpa.Connection2URL" value="${idiscover.jdbc.url}"/>
        <entry key="openjpa.Connection2DriverName" value="${idiscover.jdbc.driver}"/>
        <entry key="openjpa.jdbc.SynchronizeMappings" value="buildSchema(ForeignKeys=true)"/>

        <entry key="openjpa.ConnectionUserName" value="${idiscover.jdbc.userid}"/>
        <entry key="openjpa.ConnectionPassword" value="${idiscover.jdbc.password}"/>
        <entry key="openjpa.ConnectionURL" value="${idiscover.jdbc.url}"/>
        <entry key="openjpa.ConnectionDriverName" value="${idiscover.jdbc.driver}"/>
        <entry key="openjpa.jdbc.SynchronizeMappings" value="buildSchema(ForeignKeys=true,Indexes=true,SchemaAction='drop,add',SchemaAction='add,deleteTableContents')"/>
        <entry key="openjpa.jdbc.SchemaFactory" value="native(ForeignKeys=true)"/>
        <entry key="openjpa.InverseManager" value="true(Action=warn)"/>
    </util:map>

    <transaction:advice id="transactionAdvice" transaction-manager="transactionManager">
        <transaction:attributes>
            <transaction:method name="find*"/>
            <transaction:method name="merge*"/>
            <transaction:method name="persist*"/>
            <transaction:method name="remove*"/>
            <transaction:method name="execute*"/>
        </transaction:attributes>
    </transaction:advice>

    <aop:config>
        <aop:pointcut id="dataBaseJpaH2" expression="execution(* ikube.discover.database.DataBaseJpaH2.*(..))"/>
        <!--<aop:pointcut id="dataBaseJpaDb2" expression="execution(* ikube.discover.database.DataBaseJpaDb2.*(..))"/>-->
        <!--<aop:pointcut id="dataBaseJpaOracle" expression="execution(* ikube.discover.database.DataBaseJpaOracle.*(..))"/>-->
        <!--<aop:pointcut id="dataBaseJpaPostgres" expression="execution(* ikube.discover.database.DataBaseJpaPostgres.*(..))"/>-->
        <!--<aop:pointcut id="dataBaseAbstract" expression="execution(* ikube.discover.database.ADataBaseJpa.*(..))"/>-->
        <aop:advisor advice-ref="transactionAdvice" pointcut-ref="dataBaseJpaH2"/>
        <!--<aop:advisor advice-ref="transactionAdvice" pointcut-ref="dataBaseJpaDb2"/>-->
        <!--<aop:advisor advice-ref="transactionAdvice" pointcut-ref="dataBaseJpaOracle"/>-->
        <!--<aop:advisor advice-ref="transactionAdvice" pointcut-ref="dataBaseJpaPostgres"/>-->
        <!--<aop:advisor advice-ref="transactionAdvice" pointcut-ref="dataBaseAbstract"/>-->
    </aop:config>

    <bean
        name="ikube.discover.database.IDataBase"
        class="ikube.discover.database.DataBaseJpaH2"
        lazy-init="false"/>

    <util:list id="contexts">
        <ref bean="search-context" />
    </util:list>

    <bean
        id="search-context"
        class="ikube.discover.Context"
        depends-on="ikube.discover.database.IDataBase"
        property:name="search-context"/>

    <bean
        id="ikube.discover.schedule.Scheduler"
        class="ikube.discover.schedule.Scheduler"
        lazy-init="false"
        depends-on="ikube.discover.cluster.IClusterManager"
        property:clusterManager-ref="ikube.discover.cluster.IClusterManager"/>

</beans>